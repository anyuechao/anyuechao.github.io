<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>iOS编程细节整理 &lt;br/&gt; | 安跃超</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="安跃超">
    <meta name="author" content="YueChao An">
    <meta name="description" content="安跃超的博客" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="安跃超" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/xcode.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/Nginx-br/" class="animsition-link">Nginx&lt;br&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Swift-br/" class="animsition-link">Swift &lt;br/&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/UNIX-br/" class="animsition-link">UNIX &lt;br/&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/dart/" class="animsition-link">dart<small>(1)</small></a></li>
				    
				    <li><a href="/categories/github-br/" class="animsition-link">github&lt;br/&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/go-br/" class="animsition-link">go&lt;br&gt;<small>(4)</small></a></li>
				    
				    <li><a href="/categories/go基础/" class="animsition-link">go基础<small>(5)</small></a></li>
				    
				    <li><a href="/categories/hexo-br/" class="animsition-link">hexo&lt;br/&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/iOS/" class="animsition-link">iOS<small>(7)</small></a></li>
				    
				    <li><a href="/categories/iOS-br/" class="animsition-link">iOS &lt;br/&gt;<small>(3)</small></a></li>
				    
				    <li><a href="/categories/iOS-dart/" class="animsition-link">iOS, dart<small>(1)</small></a></li>
				    
				    <li><a href="/categories/iOS-br/" class="animsition-link">iOS&lt;/br&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/iOS-br/" class="animsition-link">iOS&lt;br/&gt;<small>(8)</small></a></li>
				    
				    <li><a href="/categories/iOS-br/" class="animsition-link">iOS&lt;br&gt;<small>(12)</small></a></li>
				    
				    <li><a href="/categories/iOS可视化-br/" class="animsition-link">iOS可视化 &lt;br/&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/python/" class="animsition-link">python<small>(2)</small></a></li>
				    
				    <li><a href="/categories/swift/" class="animsition-link">swift<small>(3)</small></a></li>
				    
				    <li><a href="/categories/swift-br/" class="animsition-link">swift &lt;br/&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/技术篇-br/" class="animsition-link">技术篇 &lt;br/&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/技术篇-br/" class="animsition-link">技术篇&lt;br/&gt;<small>(3)</small></a></li>
				    
				    <li><a href="/categories/编辑工具/" class="animsition-link">编辑工具<small>(1)</small></a></li>
				    
				    <li><a href="/categories/编辑工具-br/" class="animsition-link">编辑工具 &lt;br&gt;<small>(2)</small></a></li>
				    
				    <li><a href="/categories/编辑工具-br/" class="animsition-link">编辑工具&lt;br&gt;<small>(1)</small></a></li>
				    
				    <li><a href="/categories/设计-交互-调研/" class="animsition-link">设计,交互,调研<small>(1)</small></a></li>
				    
				    <li><a href="/categories/调研/" class="animsition-link">调研<small>(1)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://zhangtianqi.net/" class="animsition-link">zhangtianqi</a></li>
                    
                    <li><a href="http://www.ilakeyc.gift/" class="animsition-link">ilakeyc</a></li>
                    
                    <li><a href="https://github.com/wangshiyu13" class="animsition-link">wangshiyu13</a></li>
                    
                    <li><a href="http://www.lidaze.com/" class="animsition-link">lidaze</a></li>
                    
                    <li><a href="http://liushuang.win/" class="animsition-link">feelShuang</a></li>
                    
                    <li><a href="https://github.com/EmyWong" class="animsition-link">EmyWong</a></li>
                    
                    <li><a href="http://jenko.cc/" class="animsition-link">jenko</a></li>
                    
                    <li><a href="http://liuyanwei.jumppo.com/" class="animsition-link">liuyanwei</a></li>
                    
                    <li><a href="https://github.com/casatwy" class="animsition-link">casatwy</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">安跃超</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/anyuechao" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2016-01-19T03:19:19.000Z" itemprop="datePublished">
          2016-01-19
      </time>
    
</span>
                <h1>iOS编程细节整理 <br/></h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h4 id="关于iOS开发中遇到的一些小问题及其解决方法"><a href="#关于iOS开发中遇到的一些小问题及其解决方法" class="headerlink" title="关于iOS开发中遇到的一些小问题及其解决方法"></a>关于iOS开发中遇到的一些小问题及其解决方法</h4><h4 id="tableView不全屏问题"><a href="#tableView不全屏问题" class="headerlink" title="tableView不全屏问题"></a>tableView不全屏问题</h4><pre><code>cell.separatorInset = UIEdgeInsetsMake(0, -100, 0, 0);
</code></pre><h4 id="解决有的图片显示时只是一块颜色，而显示不正常的问题"><a href="#解决有的图片显示时只是一块颜色，而显示不正常的问题" class="headerlink" title="解决有的图片显示时只是一块颜色，而显示不正常的问题"></a>解决有的图片显示时只是一块颜色，而显示不正常的问题</h4><pre><code>//渲染
UIImage *image = [UIImage imageNamed:@&quot;imageName&quot;];
image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
</code></pre><a id="more"></a>
<h4 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h4><pre><code> UIImageView *imageView = [[UIImageView     alloc]initWithImage:[UIImage imageNamed:@&quot;xiaoxin3&quot;]];
//毛玻璃效果
UIVisualEffectView *visualView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:(UIBlurEffectStyleLight)]];
visualView.frame = self.tableView.bounds;
visualView.alpha = 0.8;
[imageView addSubview:visualView];

self.tableView.backgroundView = imageView;
</code></pre><h4 id="视图截圆角"><a href="#视图截圆角" class="headerlink" title="视图截圆角"></a>视图截圆角</h4><pre><code>_customView.layer.masksToBounds = YES;
_customView.layer.cornerRadius =     self.customView.bounds.size.width/2;   
</code></pre><h4 id="使用NSURLSession请求网络数据"><a href="#使用NSURLSession请求网络数据" class="headerlink" title="使用NSURLSession请求网络数据"></a>使用NSURLSession请求网络数据</h4><pre><code> //通过单例创建Session对象
//步骤1.NSURLSession 服务器数据异步加载,作用和NSURLConnection的作用相同
NSURLSession *session = [NSURLSession sharedSession];
//步骤2.封装网络请求
NSURLRequest *request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:@&quot;baidu.com&quot;]];
//步骤3.准备加载数据,创建这个任务的task
NSURLSessionTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
    //当加载数据完成时,调用该block
    NSLog(@&quot;%@&quot;,data);

    //手动解析网络数据
    NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];

    NSLog(@&quot;%@&quot;,data);
}];

//调用此方法开始加载数据
[task resume];
</code></pre><h4 id="播放语音"><a href="#播放语音" class="headerlink" title="播放语音"></a>播放语音</h4><pre><code>//导入包
import &lt;AVFoundation/AVSpeechSynthesis.h&gt;
//声音集成器
AVSpeechSynthesizer *speechSy = [[AVSpeechSynthesizer alloc] init];
//发声器
AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc] initWithString:@&quot;i am very happy&quot;];

AVSpeechUtterance *utterance2 = [[AVSpeechUtterance alloc] initWithString:@&quot;ha ha ha&quot;];
AVSpeechUtterance *utterance3 = [[AVSpeechUtterance alloc] initWithString:_textFeild.text];

//给合成器添加发生器，让其发音
[speechSy speakUtterance:utterance];
[speechSy speakUtterance:utterance2];
[speechSy speakUtterance:utterance3];

//哪国语言
utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@&quot;en-US&quot;];
//语速
utterance.rate = 0.5;
//音高
utterance.pitchMultiplier = 1.0;
</code></pre><h4 id="webView"><a href="#webView" class="headerlink" title="webView"></a>webView</h4><pre><code> UIWebView *webView = [[UIWebView alloc]  initWithFrame:self.view.frame];
[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:myurl]]];
self.view = webView; 
</code></pre><h4 id="使用第三方SDWevImage解析图片"><a href="#使用第三方SDWevImage解析图片" class="headerlink" title="使用第三方SDWevImage解析图片"></a>使用第三方SDWevImage解析图片</h4><pre><code>[cell.imgView sd_setImageWithURL:[NSURL URLWithString:news.picUrl] placeholderImage:[UIImage imageNamed:@&quot;image&quot;]];
</code></pre><h4 id="设置cell的自适应高度"><a href="#设置cell的自适应高度" class="headerlink" title="设置cell的自适应高度"></a>设置cell的自适应高度</h4><h4 id="使用此方法必须要设置cell中的最后一个控件与cell的距离"><a href="#使用此方法必须要设置cell中的最后一个控件与cell的距离" class="headerlink" title="使用此方法必须要设置cell中的最后一个控件与cell的距离"></a>使用此方法必须要设置cell中的最后一个控件与cell的距离</h4><pre><code>self.myTableView.rowHeight =   UITableViewAutomaticDimension;
self.myTableView.estimatedRowHeight = 100;
</code></pre><h4 id="让音乐在后台播放"><a href="#让音乐在后台播放" class="headerlink" title="让音乐在后台播放"></a>让音乐在后台播放</h4><pre><code>[AVAudioSession sharedInstance]setCategory:AVAudioSessionCategoryPlayback error:nil];     
</code></pre><h4 id="将URL中的汉字转换成utf-8格式，拼接到URL字符串中"><a href="#将URL中的汉字转换成utf-8格式，拼接到URL字符串中" class="headerlink" title="将URL中的汉字转换成utf-8格式，拼接到URL字符串中"></a>将URL中的汉字转换成utf-8格式，拼接到URL字符串中</h4><pre><code>NSString *typeString = (__bridge NSString *)CFURLCreateStringByAddingPercentEscapes(NULL,(__bridge CFStringRef)@&quot;健康&quot;,NULL,(CFStringRef)@&quot;!*&apos;();:@&amp;=+$,/?%#[]&quot;,kCFStringEncodingUTF8);    
</code></pre><h4 id="去除解析出来的数据带的-HTML-标记"><a href="#去除解析出来的数据带的-HTML-标记" class="headerlink" title="去除解析出来的数据带的 HTML 标记"></a>去除解析出来的数据带的 HTML 标记</h4><pre><code>- (NSString *)filterHTML:(NSString *)html{
NSScanner * scanner = [NSScanner scannerWithString:html];
NSString * text = nil;
while([scanner isAtEnd]==NO)
{
    //找到标签的起始位置
    [scanner scanUpToString:@&quot;&lt;&quot; intoString:nil];
    //找到标签的结束位置
    [scanner scanUpToString:@&quot;&gt;&quot; intoString:&amp;text];
    //替换字符
    html = [html stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@&quot;%@&gt;&quot;,text] withString:@&quot;&quot;];
}

return html;
}    
</code></pre><h4 id="去广告"><a href="#去广告" class="headerlink" title="去广告"></a>去广告</h4><h5 id="先到网页，找到开发者平台，依次输入并提交"><a href="#先到网页，找到开发者平台，依次输入并提交" class="headerlink" title="先到网页，找到开发者平台，依次输入并提交"></a>先到网页，找到开发者平台，依次输入并提交</h5><p>document.getElementsByClassName(‘index_mask’) -&gt;<br>    document.getElementsByClassName(‘index_mask’)[0] -&gt;<br>    document.getElementsByClassName(‘index_mask’[0].style.display = ‘none’ </p>
<p>若在网页上显示的对应的广告没了，就可以将最后一句写到下面的程序中</p>
<pre><code>-(void)webViewDidFinishLoad:(UIWebView *)webView{
[webView stringByEvaluatingJavaScriptFromString:@&quot;document.getElementsByClassName(&apos;index_mask&apos;)[0].style.display = &apos;none&apos;&quot;];
}
</code></pre><h4 id="图片自适应"><a href="#图片自适应" class="headerlink" title="图片自适应"></a>图片自适应</h4><pre><code>imgView.contentMode = UIViewContentModeScaleAspectFit;
</code></pre><h4 id="解决tableView的head不会和cell一起滚动的问题"><a href="#解决tableView的head不会和cell一起滚动的问题" class="headerlink" title="解决tableView的head不会和cell一起滚动的问题"></a>解决tableView的head不会和cell一起滚动的问题</h4><pre><code>self.tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0,self.view.frame.size.width, self.view.frame.size.height) style: UITableViewStyleGrouped];
</code></pre><h4 id="解决有navigationbar的情况下，下面的tableView与navigationbar有一段距离的问题"><a href="#解决有navigationbar的情况下，下面的tableView与navigationbar有一段距离的问题" class="headerlink" title="解决有navigationbar的情况下，下面的tableView与navigationbar有一段距离的问题"></a>解决有navigationbar的情况下，下面的tableView与navigationbar有一段距离的问题</h4><pre><code>self.automaticallyAdjustsScrollViewInsets = NO;
</code></pre><h4 id="数据再cell中解析，给cell做自适应高度时，无法实现"><a href="#数据再cell中解析，给cell做自适应高度时，无法实现" class="headerlink" title="数据再cell中解析，给cell做自适应高度时，无法实现"></a>数据再cell中解析，给cell做自适应高度时，无法实现</h4><p>可能是因为cell出现时，自适应高度已经实现了，但是还没有内容，所以想办法先刷新一下数据（使用block块可以在cellForRow……方法中实现）</p>
<h4 id="如何获取UIWebView中Button事件"><a href="#如何获取UIWebView中Button事件" class="headerlink" title="如何获取UIWebView中Button事件"></a>如何获取UIWebView中Button事件</h4><pre><code>//通过在网页中添加js脚本函数，当button单击时触发该函数
//在UIWebView中会自动回调代理方法
//shouldStartLoadWithRequest:navigationType
</code></pre><h4 id="批量上传和下载实现"><a href="#批量上传和下载实现" class="headerlink" title="批量上传和下载实现"></a>批量上传和下载实现</h4><pre><code>//网页的实现方式
//mutipart-formdata post表单
//iOS的实现方式
//通过在线程技术中完成批量上传的功能
</code></pre><h4 id="如何使用SDWebImage中的方法实现实时个人头像更新"><a href="#如何使用SDWebImage中的方法实现实时个人头像更新" class="headerlink" title="如何使用SDWebImage中的方法实现实时个人头像更新"></a>如何使用SDWebImage中的方法实现实时个人头像更新</h4><pre><code>//通过修改个人信息Model类中的个人头像字符串
//因为SDWebImage中存储图片时的原理，是将url字符串进行md5加密后作为iOS本地缓存文件的文件名存储的
//所以当，个人头像没有发生改变时，即个人头像的url字符串没有发生改变，当个人头像发生改变时，个人信息Model类中的url同时也发生变化，就好了
</code></pre><h4 id="极光推送的思路"><a href="#极光推送的思路" class="headerlink" title="极光推送的思路"></a>极光推送的思路</h4><pre><code>![http://docs.jpush.io/guideline/ios_guide/]()
</code></pre><h4 id="股票K线图-画线"><a href="#股票K线图-画线" class="headerlink" title="股票K线图?画线?"></a>股票K线图?画线?</h4><pre><code>![https://github.com/zhiyu/chartee]()
</code></pre><h4 id="给一个NSDate对象，获取到一年中的第几个月中的第几天"><a href="#给一个NSDate对象，获取到一年中的第几个月中的第几天" class="headerlink" title="给一个NSDate对象，获取到一年中的第几个月中的第几天"></a>给一个NSDate对象，获取到一年中的第几个月中的第几天</h4><pre><code>NSDate *date = [NSDate date];
//获取对应属性
NSDateComponents *comp = [[NSCalendar currentCalendar] componentsInTimeZone:[NSTimeZone defaultTimeZone] fromDate:date];
/*
 @interface NSDateComponents : NSObject &lt;NSCopying, NSSecureCoding&gt;
 @property (nullable, copy) NSCalendar *calendar NS_AVAILABLE(10_7, 4_0);
 @property (nullable, copy) NSTimeZone *timeZone NS_AVAILABLE(10_7, 4_0);
 @property NSInteger era;
 @property NSInteger year;
 @property NSInteger month;
 @property NSInteger day;
 @property NSInteger hour;
 @property NSInteger minute;
 @property NSInteger second;
 @property NSInteger nanosecond NS_AVAILABLE(10_7, 5_0);
 @property NSInteger weekday;
 @property NSInteger weekdayOrdinal;
 @property NSInteger quarter NS_AVAILABLE(10_6, 4_0);
 @property NSInteger weekOfMonth NS_AVAILABLE(10_7, 5_0);
 @property NSInteger weekOfYear NS_AVAILABLE(10_7, 5_0);
 @property NSInteger yearForWeekOfYear NS_AVAILABLE(10_7, 5_0);
 @property (getter=isLeapMonth) BOOL leapMonth NS_AVAILABLE(10_8, 6_0);
 @property (nullable, readonly, copy) NSDate *date NS_AVAILABLE(10_7, 4_0);
 */
//获取一年中的第几天
//小范围参数:NSCalendarUnitDay
//大范围参数:NSCalendarUnitYear
/*
 NSCalendarUnitEra = kCFCalendarUnitEra,
 NSCalendarUnitYear = kCFCalendarUnitYear,
 NSCalendarUnitMonth = kCFCalendarUnitMonth,
 NSCalendarUnitDay = kCFCalendarUnitDay,
 NSCalendarUnitHour = kCFCalendarUnitHour,
 NSCalendarUnitMinute = kCFCalendarUnitMinute,
 NSCalendarUnitSecond = kCFCalendarUnitSecond,
 NSCalendarUnitWeekday = kCFCalendarUnitWeekday,
 NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal,
 */
NSInteger day = [[NSCalendar currentCalendar] ordinalityOfUnit:NSCalendarUnitDay inUnit:NSCalendarUnitYear forDate:date];
NSLog(@&quot;%ld&quot;,day);
</code></pre><h4 id="runtime的实现原理"><a href="#runtime的实现原理" class="headerlink" title="runtime的实现原理"></a>runtime的实现原理</h4><pre><code>链接: http://pan.baidu.com/s/1i4ijIsP 密码: k661
</code></pre><h4 id="tableView滑动时卡顿的处理办法"><a href="#tableView滑动时卡顿的处理办法" class="headerlink" title="tableView滑动时卡顿的处理办法"></a>tableView滑动时卡顿的处理办法</h4><p>//一般遇到卡顿时候，会出现的原因<br>//1、在单元格中使用了同步下载图片，解决方法是使用多线程技术<br>//2、在单元格中自定义高度布局时，进行了大量的计算，解决方法是使用缓存技术，在下载完数据后，自动生成一个对象应该所占的高度</p>
<h4 id="一-内存管理情况"><a href="#一-内存管理情况" class="headerlink" title="一.内存管理情况"></a>一.内存管理情况</h4><ul>
<li>1- autorelease，当用户的代码在持续运行时，自动释放池是不会被销毁的，这段时间内用户可以安全地使用自动释放的对象。当用户的代码运行告一段 落，开始等待用户的操作，自动释放池就会被释放掉（调用dealloc），池中的对象都会收到一个release，有可能会因此被销毁。</li>
<li>2-成员属性：<br>readonly：不指定readonly，默认合成getter和setter方法。外界毫不关心的成员，则不要设置任何属性，这样封装能增加代码的独立性和安全性。相当于私有成员？<br>assign：表示只进行简单的赋值，不会发送retain消息。<br>retain：会向旧值发送release消息，向新值发送retain消息。<br>copy：向旧值发release消息，向新值发送copy消息。<br>3-引用计数特殊情况：<br>NSArray：当把一个对象添加到NSArray时，对象的引用计数会加1，移除时会减1。<br>UIView：addGestureRecognizer会对手势识别器的引用计数加1，removeGestureRecognizer会减1。</li>
</ul>
<h4 id="二-图形API"><a href="#二-图形API" class="headerlink" title="二 .图形API"></a>二 .图形API</h4><p>这个讲的好，清晰明确：<a href="http://www.cocoachina.com/bbs/read.php?tid=77731&amp;page=1" target="_blank" rel="noopener">图形API</a></p>
<ul>
<li><p>1-Quartz2D，的绘图总是发生在图形环境（Graphics Context）中。视图会在调用drawRect:方法进行绘图之前，创建好图形环境，<br>通过UIGraphicsGetCurrentContext函数来获得这个图形环境。<br>如果直接在图像或者PDF上绘图，需要调用CGBitmapContextCreate或者CGPDFContextCreate函数来创建图形环境。<br>Quartz2D绘图的基础元素是路径。路径可以是一些基础几何形状，也可以是这些几何形状的组合。<br>当需要创建一条路径时，应当调用CGContextBeginPath函数；<br>当需要将路径绘制的起点移动到一个位置时，应当调用CGContextMoveToPoint函数；<br>当想绘制一条线段时，应当调用CGContextAddLineToPoint。 CTM（当前变换矩阵）将绘图从用户空间映射到设备控件。<br>当图形环境刚刚创建时，CTM初始化为一个单位矩阵。<br>对CTM进行平移变换应当调用CGContextTranslateCTM函数，进行旋转变换应当调用CGContextRotateCTM函数，进行缩放变换应当调用CGContextScaleCTM函数。</p>
</li>
<li><p>2-UIBezierPath<br>使用UIBezierPath绘图的好处：</p>
<ul>
<li>采用系统坐标系</li>
<li><p>在Core Graphics的基础上封装，具有Core Graphics的主要功能，无需考虑图形环境。</p>
<p>   UIBezierPath* pathLines = [UIBezierPath bezierPath];<br>   [pathLines moveToPoint:point1]; // 移动到point1位置<br>   [pathLines addLineToPoint:point2]; // 画一条从point1到point2的线<br>   pathLines.lineWidth = 5.0; // 线宽<br>   ［UIColor redColor] set]; // 颜色设置<br>   [pathLines stroke]; // 开始描绘<br>在同一UIBazierPath中，只能采用相同的颜色和线宽。<br>可以调用closePath，从当前点画一条直线到当前子路径的初始点。如果要填充路径，应当使用fill方法，此方法会填充路径中得所有封闭子路径。</p>
</li>
</ul>
</li>
</ul>
<h4 id="三-容器"><a href="#三-容器" class="headerlink" title="三.容器"></a>三.容器</h4><pre><code>-NSArray和NSMutableArray
+array：创建一个空数组
+arrayWithArray：从另一个数组创建新的数组
+arrayWithContentsOfFile：读文件创建数组
+arrayWithObject：创建一个数组，其中包含一个给定对象
+arrayWithObjects
+arrayWithObjects:count: 从C数组创建
-containsObject：是否包含一个元素
-count：数量
-lastObject：返回最后一个
-objectAtIndex：返回某一个
-objectsAtIndexes：返回一组，类型为NSArray
-indexOfObject：返回对象索引
-arrayByAddingObject：原数组最后加一个对象，产生一个新的数组
-arrayByAddingObjectsFromArray：在原数组的最后添加另一个数组中的所有对象，产生一个新数组
-subarrayWithRange：抽取原数组中得一部分，产生一个新的数组
-isEqualToArray：比较两个数组是否相同
-writeToFile:atomically：保存数组至一个文件
-writeToURL:atomically：保存数组至一个URL
-addObject：在数组最后添加一个对象
-addObjectsFromArray：在原数组最后添加另一个数组的全部对象
-insertObject:atIndex：向原数组制定位置添加一个对象
-insertObjects:atIndexes：向原数组中一系列位置添加一系列对象
-removeAllObjects：移除数组中的全部对象
-removeLastObject：移除数组中最后一个对象
-removeObject：移除一个对象
-removeObjectAtIndex：移除位于指定位置的对象
-removeObjectsAtIndexes：移除位于一系列位置的对象
-replaceObjectAtIndex:withObject用给定对象替换位于指定位置的对象
-replaceObjectsAtIndexes:withObjects：多对象，多位置版本
-setArray：用另一个数组中的所有对象来替换当前数组中的所有对象
-NSDictionary与NSMutableDictionary
+dictionary
+dictionaryWithContentsOfFile
+dictionaryWithContentsOfURL
+dictionaryWithDictionary
+dictionaryWithObject:forKey
+dictionaryWithObjects:forKeys
+dictionaryWithObjectsAndKeys
-count：数量
-allKeys：返回一个数组，包含字典中的所有关键字。
-allKeysForObject：返回一个数组，包含所有对应到给定对象的关键字。
-valueForKey：通过字符串查找数值。
-writeToFile:atomically
-writeToURL:atomically
-setValue:forKey： 加键-值对
-addEntriesFromDictionary： 添加另一个字典中得所有条目
-setDictionary：将原字典中条目设置为另一个字典中得所有条目
-removeObjectForKey：移除一个关键字的对应条目
-removeAllObjects：移除所有条目
-removeObjectsForKeys：移除一系列关键字的对应条目
</code></pre><h4 id="四-文件系统"><a href="#四-文件系统" class="headerlink" title="四.文件系统"></a>四.文件系统</h4><ul>
<li>1- 概述<br>bundle（沙盒）：一个应用只能在自己的沙盒中读取或存储文件，而不能操作其他沙盒中的文件。好处：保护应用的隐私不受侵犯，保护系统文件的安排，应用删除后相关文件也能被全部清除。<br>每个应用都有自己的沙盒，沙盒的根目录的获取方法是NSHomeDirectory()。<br>根目录下的内容：<br>-.app文件，实际上是一个文件夹，包含了可执行文件、Nib文件、图片资源、plist等。XCode中能看到的资源，及编译后的可执行文件，都封装在app中。<br>-<code>Documents</code>文件夹，用于存放你的应用所产生的数据，该文件夹可通过iTunes备份，可以存储游戏进度等。<br>-<code>Library</code>文件夹，用于存放用户偏好和临时文件。<br>-<code>tmp</code>文件夹是系统的中转站。</li>
<li>2-文件管理器<br><code>NSFileManager</code>，<code>defaultManager()</code>返回一个文件管理器的单例（多线程下不安全）。init()，在多线程编程中应尽量使用init()。</li>
</ul>
<p>代理方法：<code>-fileManager:shouldRemoveItemAtPath</code>和-<code>fileManager:shouldRemoveItemAtURL</code>在移除操作之前被调用。</p>
<p><code>-removeItemAtPath:error：</code>删除位于指定路径的文件、连接、目录（及其所有子目录、文件）。<br><code>-removeItemAtURL:error：</code>同上。</p>
<p><code>-contentOfDirectoryAtPath：</code>查找所有位于给定路径的子路径和文件。返回值为一个数组，其中包含了NSString对象。查找只在当前目录进行，不会进入下一层目录。</p>
<p><code>-subpathsAtPath：</code>查找给定路径下的所有子路径。深度查找，不限于当前层，也会查找package的内容。</p>
<p><code>-fileExistsAtPath：</code>判断文件是否位于一个路径下面。</p>
<p><code>-isReadableFileAtPath：</code>查询文件的可读性</p>
<p><code>-isWritableFileAtPath：</code>可写性</p>
<p><code>-isExecutableFileAtPath：</code>查询文件的可执行性</p>
<p><code>-isDeletableFileAtPath：</code>可删除性</p>
<ul>
<li><p>3-NSString的路径功能</p>
<pre><code>-pathWithComponent：参数是一堆components构成的数组，返回的路径是由这些components连接而成的路径字符串，相邻components之间用/隔开。
-pathComponents：返回一个数组，包含路径中的components。
-fileSystemRepresentation：返回C字符串
-isAbsolutePath：判断是否为绝对路径
-pathExtension：返回文件的扩展名，没有的就返回空字符串
-stringByAppendingPathComponents ：向现有路径添加一个component。斜杠/会被自动加上
-stringByAppendingPathExtension：向现有路径加上文件的扩展名
-stringByDeletingLastPathComponent：移除最后一个路径component
-stringByDeletingPathExtension：删除路径扩展名
-stringByAppendingPaths：参数为一个数组，此方法将数组中的字符串对象作为路径一次添加到源字符串后面。
</code></pre><p>例子：</p>
<pre><code>NSString homePath = NSHomeDirectory();
NSString docPath = [homePath stringByAppendingFormat:@&quot;/Documents&quot;];
</code></pre></li>
</ul>
<h4 id="五-UIAlertController"><a href="#五-UIAlertController" class="headerlink" title="五.UIAlertController"></a>五.UIAlertController</h4><pre><code>UIAlertController * alterVC = [UIAlertController alertControllerWithTitle:@&quot;标题&quot; message:alter preferredStyle:UIAlertControllerStyleAlert];
UIAlertAction * veryfiAction  = [UIAlertAction actionWithTitle:@&quot;确认&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * action) {      
    NSLog(@&quot;确认&quot;);
}]; 
[alterVC addAction:veryfiAction];
[self.window.rootViewController presentViewController:alterVC animated:YES completion:nil];
</code></pre><h4 id="六-旋转"><a href="#六-旋转" class="headerlink" title="六.旋转"></a>六.旋转</h4><ul>
<li>1- interfaceOrientation属性查询当前的界面方向。</li>
<li>2- rotatingHeaderView方法来查询当前导航视图。</li>
<li>3- rotatingFooterView来查询当前的标签条。<h4 id="七-快速拨打电话接口"><a href="#七-快速拨打电话接口" class="headerlink" title="七.快速拨打电话接口"></a>七.快速拨打电话接口</h4>openURL能帮助你运行Maps，SMS，Browser,Phone甚至其他的应用程 序。这是Iphone开发中我经常需要用到的一段代码，它仅仅只有一行而已。</li>
</ul>
<pre><code>［UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;tel://8004664411&quot;］; 
</code></pre><p>这个程序通过基础的协议支持拨打电话的功能。</p>
<h4 id="八-区分设备类型的方法"><a href="#八-区分设备类型的方法" class="headerlink" title="八.区分设备类型的方法"></a>八.区分设备类型的方法</h4><p>打电话功能只有iPhone支持，对于其他设备对应按钮应该禁用。</p>
<p>用[UIDevice currentDevice].model，这个返回的是一个NSString，你可以做如下判断就能知道设备是iPad还是iPhone.</p>
<pre><code>if (［UIDevice currentDevice].model            
 rangeOfString:@&quot;iPad&quot;].location != NSNotFound) { 
  NSLog(@&quot;This is an iPad!&quot;); 
</code></pre><p>}<br>用UI_USER_INTERFACE_IDIOM()方法，这是系统定义的一条宏。使用方法也很简单。</p>
<pre><code> if (UI_USER_INTERFACE_IDIOM() ＝＝ UIUserInterfaceIdiomPad)      
{ 
 NSLog(@&quot;This is an iPad!&quot;); 
 }
</code></pre><h4 id="九-并发编程"><a href="#九-并发编程" class="headerlink" title="九.并发编程"></a>九.并发编程</h4><ul>
<li>1-GCD-Grand Central Dispatch，GCD使用队列来管理多个任务，而每个任务是以块（其定义类似于函数）来描述的。GCD从队列中读取这些要完成的任务，然后其多核执行 引擎负责将这些任务分配给它所管理的线程。和手动线程管理相比，GCD能极大地优化线程管理，并极大地减少创建和销毁线程所带来的额外开销。除了在多核系 统上得性能改进之外，GCD还能帮助提高应用的响应速度，并让代码更为干净，易于维护。</li>
<li>2-NSOperationQueue-操作队列，可以极大地减少开发者在并发编程中的负担，并且操作队列有一套Objective-C的API，使用起来方便。<br>基本操作单位-NSOperation，操作。<br>操作是封装了一个与任务有关的代码与数据的抽象类，需要继承NSOperation，并且描述相关的任务。操作对象是一次性的，它只能执行一次，下一次，需要创建一个新的实例。<br>可以通过addDependency:方法为操作添加相互依赖性。假设操作A依赖于操作B，如果操作B没有结束，操作A就不会开始执行。完成是指 执行完，或者取消了操作。有时需要对操作是否成功作出判断。通过removeDependency:方法来移除操作的相互依赖性。<br>操作的一个属性是isConcurrent。当使用操作队列来管理这些操作时，isConcurrent应当设置为NO，这时应当重载 NSOperation的main函数（在类中保存controller对象-weak，并在main中调用controller的方法）。 isReady属性用于描述操作是否已经可以开始执行，isExecuting属性表示操作是否正在执行当中，isFinished属性表示操作是否顺利 完成，isCancelled属性则表示操作已经取消。<br>可以在操作运行中取消它的运行，只需要给它发送cancel消息即可。在继承NSOperation类时，也需要支持cancel方法。<br>如果只需要简单的操作，不想继承NSOperation类，可以使用<code>NSInvocationOperation</code>类，这个类中的-<code>initWithTarget:selector:object:</code>方法能帮助你方便地选择人物的对象和相应的功能。<br>操作的执行顺序取决于各自的优先级和相互之间的依赖性。<br>操作队列有两种方式来执行其中的操作。第一种是开辟新线程来运行这些操作，第二种则是通过GCD来运行这些操作。但是无论如何，都不需要手动管理 线程。尽量使用操作队列，只有在操作队列的效率明显不足时才转向GCD。因为操作队列是封装在GCD的基础之上的，虽然增加了一些额外开销，但是也具有更 加完善的功能。例子是<code>TestNSOperation</code>。</li>
</ul>
<h4 id="十-忙碌指示器"><a href="#十-忙碌指示器" class="headerlink" title="十.忙碌指示器"></a>十.忙碌指示器</h4><pre><code>UIActivityIndicator。
UIActivityIndicatorView *activityIndicatior = ［UIActivityIndicatorView alloc] initWithActivityIndicatorStyle: UIActivityIndicatorViewStyleWhiteLarge]; 
activityIndicator.center = CGPointMake(512, 384); 
[self.view addSubview: activityIndicator]; 
[activityIndicator startAnimating];  
[activityIndicator stopAnimating]; 
[activityIndicator removeFromSuperView];
</code></pre><h4 id="十一-媒体播放"><a href="#十一-媒体播放" class="headerlink" title="十一.媒体播放"></a>十一.媒体播放</h4><ul>
<li>1- 音频<br>[1] 音乐往往是存储在iPod曲库（注意位置）中的，可以通过媒体选择器<code>media picker</code>或者媒体查询<code>media query</code>读取，然后用音乐播放器<code>MPMusicPlayerController</code>播放。</li>
</ul>
<pre><code>MPMusicPlayerController *musicPlayer = [MPMusicPlayerController applicationMusicPlayer]; 
[musicPlayer setShufleMode: MPMusicShuffleModeSongs]; 
[musicPlayer setRepeatMode: MPMusicRepeatModeAll]; 
[musicPlayer setQueueWithQuery: [MPMediaQuery songsQuery］; 
[musicPlayer play];
</code></pre><p>applicationMusicPlayer返回的播放器，在你的应用中播放音乐。它不会影响到iPod播放器，也不能从iPod播放器重获取信息。<br>iPodMusicPlayer返回的是iPod播放器，在你推出应用后，所有的设置都会影响到之后设备上的iPod播放器。<br>获得音乐播放器后，需要为它设置一个播放队列。可以用setQueueWithQuery:放方法，通过媒体查询MPMediaQuery来设置 播放队列，也可以用setQueueWithItemCollection:方法，通过MPMdiaItemCollection来设置播放队列。<br>重复模式repeatMode可以设置为不重复、重复当前曲目、或整个播放列表；乱序播放shuffleMode可以设置为不乱序、乱序播放曲目或乱序播放专辑；音量volume的设置与音频播放器一样。<br>skipToNextItem跳到下一首，skipToPreviousItem跳到上一首，skipToBegin跳到第一首。<br>对应的宏都是以MPMusic开头。</p>
<p>   [2] 利用系统声音服务来播放短暂音效（时长30秒以内），并震动：   </p>
<pre><code>AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);  
播放指定音效：
NSURL *fileURL = [NSURL fileURLWithPath: path isDirectory: NO];  
// 创建音效ID 
SystemSoundID soundID; 
AudioServiceCreateSystemSoundID((CFURLRef) fileURL, &amp;soundID); 
// 播放声音 
AudioServicesPlaySystemSound(soundID);
</code></pre><p>[3] 音频播放器</p>
<p>   没有时长限制</p>
<pre><code>NSURL *fileURL = [NSURL fileURLWithPath: path isDirectory: NO]; 
// 用URL来初始化音频播放器-播放的不是iPod曲库中的音乐 
AVAudioPlayer* player = ［AVAudioPlayer alloc] initWithContentsOfURL: fileURL error: NO]; 
// 准备播放 
[player prepareToPlay]; 
// 设置代理 
[player setDelegate: self]; 
方法：play、pause、stop。可以通过playing属性查询播放器是否正在播放当中，可以通过volume属性来修改和查询播放器的播放增益（从0.0到1.0），可通过setting属性查询播放器其他设置。

duration表示音频的时间长度， currentTime表示当前播放到的时间。播放结束后可以通过代理方法audioPlayerDidFinishPlaying:来处理播放后设置。
</code></pre><ul>
<li>2- 视频<br>视频播放可以采用网页视图<code>UIWebView</code>进行嵌入式播放（能播放YouTube视频），或者采用电影播放器<code>MPMoviePlayerController</code>进行播放。<br>[1] 电影播放器</li>
</ul>
<pre><code>MPMoviePlayerController *player =     ［MPMoviePlayerController alloc]initWithContentURL: url]; 
// 设置播放器的大小，并将其加入视图中 
[player.view setFrame: rectFrame]; 
[self.view addSubView: player.view]; 
播放器的背景视图backgroundView。 
全屏[player setFullscreen: YES animated: YES]; 
播放另一个影片[player setContentURL: newURL]; 
[player requestThumbnailImagesAtTimes:arrayTimes timeOption:MPMovieTimeOptionNearestKeyFrame]; // 表示播放器不会在你所指定的时间去截取预览，而是在绝对时间的附近几帧中寻找效果最好的帧做为预览。 
</code></pre><p><code>scalingMode</code>规定了影片的缩放模式。<br><code>initialPlaybackTime</code>用来控制视频开始播放的时间，单位是秒。<br>如果视频源在网络上，那么需要正确设置服务器端的<code>mimeType</code>。</p>
<h4 id="十二-运行环-runloop"><a href="#十二-运行环-runloop" class="headerlink" title="十二.运行环-runloop"></a>十二.运行环-runloop</h4><p>运行环作用于一个iOS应用的整个生命周期。它负责监视各种输入事件，并且在合适的时候对这些输入进行分配。应用的每一个线程都有且仅有一个运行环。你自己不需要创建也不需要销毁运行环，但是可以通过<code>currentRunLoop</code>方法来获取当前的运行环。</p>
<h4 id="十三-定时器"><a href="#十三-定时器" class="headerlink" title="十三.定时器"></a>十三.定时器</h4><p>由于运行环机制，定时器的精度不高，只能用于一般性延时。<br>例子：拼图游戏，DeskViewController.m。<br>NSObject类的定时方法。</p>
<pre><code>performSelector: withObject: afterDelay: 运行方法，参数，时间（秒）。
performSelectorOnMainThread: withObject: waitUntilDone: 在主线程中，运行参数selector所指定的方法，如果waitUntilDone参数为YES，那么当前线程会被阻拦，直到selector运行完。
performSelector: onThread: withObject: waitUntilDone:同上，但不一定在主线程中运行。
performSelectorInBackground: withObject: 开启一个新线程，用于运行selector方法，selector方法应负责线程的初始化。
cancelPreviousPerformRequestsWithTarget:取消与一个目标相关的所有计划好的动作。
cancelPreviousPerformRequestsWithTraget: selector: object只取消特定的计划动作。
</code></pre><h4 id="十四-随机数"><a href="#十四-随机数" class="headerlink" title="十四.随机数"></a>十四.随机数</h4><p>0~1之间随机数</p>
<pre><code>CG_INLINE float genRandomNum() 
{ 
return (float)arc4random/ARCRANDOM_MAX; 
}
</code></pre><h4 id="十五-地图与连接服务器"><a href="#十五-地图与连接服务器" class="headerlink" title="十五.地图与连接服务器"></a>十五.地图与连接服务器</h4><p>[1] 添加框架MapKit.framework。使用MKMapView来呈现地图。注意应当直接使用此类，而不是继承之。如果希望在MKMapView类之上添加功能，可以使用MKMapViewDelegate协议。</p>
<p>初始化：</p>
<pre><code>MKMapView *mapView = ［MKMapView alloc] initWithFrame: rect]; 
初始化之后并不直接显示，还需要指定显示的地图区域：
CLLocationCoordinate2D coordinate; 
coordinate.latitude = latitudeValue; // 纬度 
coordinate.longtitude = longtitudeValue; // 精度 
// 指定显示区域，width和height单位都是米 
mapView.region = MKCoordinateRegionMakeWithDistance(coordinate, width, height); 
之后可以通过addSubview添加地图。
</code></pre><p> 属性：<code>showsUserLocation</code>-为YES，系统会持续跟踪用户的位置<br>          <code>userLocationVisible</code>-为YES，将显示用户所在位置<br>显示地图之后，常常希望在地图上添加标注，这需要创建一个类，并实现MKAnnotation协议，这个类叫做标注对象。标注对象往往实现 setCoordinate:方法来设置其坐标。在地图视图上，可以设置标注对象的坐标，然后添加进去，这样地图上就会出现一个标注。代理方法title 和subtitle能够在标注上显示标题和副标题。</p>
<pre><code>// 初始化 
   mapView = ［MKMapView alloc] initWithFrame: CGRectMake(100, 100, 550, 700)]; 
   mapView.showsUserLocation = TRUE; 
   mapView.mapType = MKMapTypeStandard; 
   mapView.delegate = self; 
   // 设置坐标 
   CLLocationCoordinate2D coordinate; 
   coordinate.latitude = 37.31; 
   coordinate.longtitude = -122.03; 
   mapView.region = MKCoordinateRegionMakeWithDistance(coordinate, 4000, 6000); // 4000米宽，6000米高的区域 
   [self.view insertSubview: mapView atIndex: 0];
</code></pre><h4 id="十六-通过storyboard来初始化一个controller"><a href="#十六-通过storyboard来初始化一个controller" class="headerlink" title="十六.通过storyboard来初始化一个controller"></a>十六.通过storyboard来初始化一个controller</h4><pre><code>CBigDesignImageViewController *imageViewController = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;BigImageController&quot;];  
   BigImageController是要在storyboard中设置的Identifier属性。
</code></pre><h4 id="十七-给UIView子类设置阴影，包括各种控件"><a href="#十七-给UIView子类设置阴影，包括各种控件" class="headerlink" title="十七.给UIView子类设置阴影，包括各种控件"></a>十七.给UIView子类设置阴影，包括各种控件</h4><ul>
<li>1 导入QuartzCore framework</li>
<li>2 #import</li>
<li><p>3 编码：</p>
<pre><code>［imgView layer] setShadowOffset:CGSizeMake(5, 5)]; // 阴影的范围  
［imgView layer] setShadowRadius:2]; // 阴影扩散的范围控制  
［imgView layer] setShadowOpacity:1]; // 阴影透明度  
// 阴影的颜色     
［imgView layer] setShadowColor:[UIColor brownColor].CGColor];
</code></pre><h4 id="十八-设置UIScrollView滚动速度"><a href="#十八-设置UIScrollView滚动速度" class="headerlink" title="十八.设置UIScrollView滚动速度"></a>十八.设置UIScrollView滚动速度</h4></li>
</ul>
<pre><code>// 自动滚动太快，效果不好，这里把动画设置慢点，注意下面要直接赋值contentOffset，不要用带animated参数的函数，否则动画会出问题，因为两处都是动画效果。   
  [UIScrollView animateWithDuration:1.0f  
                       delay:0  
                       options:UIViewAnimationCurveLinear 
                       animations:^{ 
                           scrollView.contentOffset = CGPointMake(0, 0);  
                       } 
                       completion:^(BOOL finished){} 
                       ];  
// 如果在减速滚动过程中，按了刷新按钮，执行上面的动画，会出现重置的位置，y不是0的情况，这里再调用一次，滚动到0。 
[scrollView setContentOffset:CGPointMake(0, 0) animated:YES];
</code></pre><h4 id="十九-EXC-BAD-ACCESS"><a href="#十九-EXC-BAD-ACCESS" class="headerlink" title="十九.EXC_BAD_ACCESS"></a>十九.EXC_BAD_ACCESS</h4><pre><code>Here’s the advice I generally give to developers when you hit an EXC_BAD_ACCESS error:
</code></pre><ul>
<li>Set the NSZombieEnabled argument in your executable options, which sometimes helps narrow down the cause</li>
<li>Run with Apple Instruments such as Leaks to look for memory issues</li>
<li>Set a breakpoint in your code and step through until you narrow down where it’s crashing<br>Tried and true “comment out code till it works” then backtrack from there :]<br>设置 NSZombieEnabled 的方法：<br>你可以点击 Xcode 菜单 Product -&gt; Edit Scheme -&gt; Arguments, 然后将点击”加号”, 将 NSZombieEnabled 参数加到 Environment Variables 窗口中, 后面的数值写上 ”YES”.<br>或者在 Xcode4 菜单 Product -&gt; Edit Scheme -&gt; Diagnostics 设置窗口中直接勾上 Enable Zombie Objects 即可，Xcode 可用 cmd＋shift＋&lt; 进到这个窗口。</li>
</ul>
<h4 id="二十-iOS-8-及-iOS-9"><a href="#二十-iOS-8-及-iOS-9" class="headerlink" title="二十 iOS 8 及 iOS 9"></a>二十 iOS 8 及 iOS 9</h4><p>定位<br>在IOS8中定位功能新增了两个方法：</p>
<pre><code>- (void)requestWhenInUseAuthorization __OSX_AVAILABLE_STARTING(__MAC_NA, __IPHONE_8_0);

- (void)requestAlwaysAuthorization __OSX_AVAILABLE_STARTING(__MAC_NA, __IPHONE_8_0);
</code></pre><p>这两个新增的方法导致，之前写的程序在iOS8运行会出现，定位功能无法正常使用<br>这样让iOS8正常使用定位功能呢？</p>
<p><1>你需要在info.plist表里面添加两条变量<br>在Info.plist中加入两个缺省没有的字段</1></p>
<pre><code>NSLocationAlwaysUsageDescription//一直允许
NSLocationWhenInUseUsageDescription//使用时允许
</code></pre><h4 id="iOS-9-网络请求"><a href="#iOS-9-网络请求" class="headerlink" title="iOS 9 网络请求"></a>iOS 9 网络请求</h4><p>iOS9把所有的http请求都改为https了：iOS9系统发送的网络请求将统一使用TLS 1.2 SSL。采用TLS 1.2 协议，目的是 强制增强数据访问安全，而且 系统 Foundation 框架下的相关网络请求，将不再默认使用 Http 等不安全的网络协议，而默认采用 TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 Info.plist 中声明，倒退回不安全的网络请求。</p>
<ul>
<li>1.在Info.plist中添加NSAppTransportSecurity类型Dictionary。</li>
<li>2.在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES。</li>
</ul>
<h4 id="使用UIApplicationUserDidTakeScreenshotNotification来检查截图"><a href="#使用UIApplicationUserDidTakeScreenshotNotification来检查截图" class="headerlink" title="使用UIApplicationUserDidTakeScreenshotNotification来检查截图"></a>使用UIApplicationUserDidTakeScreenshotNotification来检查截图</h4><p>在iOS7之前，像Snapshot或是Facebook Poke这样的app是使用一些很精巧的方法来检测用户是否有截图。然而，iOS7提供一个崭新的推送方法：UIApplicationUserDidTakeScreenshotNotification。只要像往常一样订阅即可知道什么时候截图了。</p>
<h4 id="调用AVFountain框架实现照相功能"><a href="#调用AVFountain框架实现照相功能" class="headerlink" title="调用AVFountain框架实现照相功能"></a>调用AVFountain框架实现照相功能</h4><pre><code>//
//  ViewController.m
//  AVFoundationCamera
//

#import &quot;ViewController.h&quot;
#import &lt;AVFoundation/AVFoundation.h&gt;
#import &lt;AssetsLibrary/AssetsLibrary.h&gt;
typedef void(^PropertyChangeBlock)(AVCaptureDevice *captureDevice);

@interface ViewController ()

@property (strong,nonatomic) AVCaptureSession *captureSession;//负责输入和输出设备之间的数据传递
@property (strong,nonatomic) AVCaptureDeviceInput *captureDeviceInput;//负责从AVCaptureDevice获得输入数据
@property (strong,nonatomic) AVCaptureStillImageOutput *captureStillImageOutput;//照片输出流
@property (strong,nonatomic) AVCaptureVideoPreviewLayer *captureVideoPreviewLayer;//相机拍摄预览图层
@property (weak, nonatomic) IBOutlet UIView *viewContainer;
@property (weak, nonatomic) IBOutlet UIButton *takeButton;//拍照按钮
@property (weak, nonatomic) IBOutlet UIButton *flashAutoButton;//自动闪光灯按钮
@property (weak, nonatomic) IBOutlet UIButton *flashOnButton;//打开闪光灯按钮
@property (weak, nonatomic) IBOutlet UIButton *flashOffButton;//关闭闪光灯按钮
@property (weak, nonatomic) IBOutlet UIImageView *focusCursor; //聚焦光标



@end

@implementation ViewController

#pragma mark - 控制器视图方法
- (void)viewDidLoad {
    [super viewDidLoad];

}

-(void)viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];
    //初始化会话
    _captureSession=[[AVCaptureSession alloc]init];
    if ([_captureSession canSetSessionPreset:AVCaptureSessionPreset1280x720]) {//设置分辨率
        _captureSession.sessionPreset=AVCaptureSessionPreset1280x720;
}
    //获得输入设备
    AVCaptureDevice *captureDevice=[self     getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头
    if (!captureDevice) {
        NSLog(@&quot;取得后置摄像头时出现问题.&quot;);
        return;
    }

    NSError *error=nil;
    //根据输入设备初始化设备输入对象，用于获得输入数据
    _captureDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:captureDevice error:&amp;error];
    if (error) {
        NSLog(@&quot;取得设备输入对象时出错，错误原因：%@&quot;,error.localizedDescription);
        return;
    }
    //初始化设备输出对象，用于获得输出数据
    _captureStillImageOutput=[[AVCaptureStillImageOutput alloc]init];
    NSDictionary *outputSettings = @{AVVideoCodecKey:AVVideoCodecJPEG};
    [_captureStillImageOutput setOutputSettings:outputSettings];//输出设置

    //将设备输入添加到会话中
    if ([_captureSession canAddInput:_captureDeviceInput]) {
    [_captureSession addInput:_captureDeviceInput];
    }

    //将设备输出添加到会话中
    if ([_captureSession canAddOutput:_captureStillImageOutput]) {
        [_captureSession addOutput:_captureStillImageOutput];
    }

    //创建视频预览层，用于实时展示摄像头状态
    _captureVideoPreviewLayer=[[AVCaptureVideoPreviewLayer alloc]initWithSession:self.captureSession];

    CALayer *layer=self.viewContainer.layer;
    layer.masksToBounds=YES;

    _captureVideoPreviewLayer.frame=layer.bounds;
            _captureVideoPreviewLayer.videoGravity=AVLayerVideoGravityResizeAspectFill;//    填充模式
    //将视频预览层添加到界面中
    //[layer addSublayer:_captureVideoPreviewLayer];
    [layer insertSublayer:_captureVideoPreviewLayer     below:self.focusCursor.layer];

    [self addNotificationToCaptureDevice:captureDevice];
    [self addGenstureRecognizer];
    [self setFlashModeButtonStatus];
}

-(void)viewDidAppear:(BOOL)animated{
    [super viewDidAppear:animated];
    [self.captureSession startRunning];
}

-(void)viewDidDisappear:(BOOL)animated{
    [super viewDidDisappear:animated];
    [self.captureSession stopRunning];
}

-(void)dealloc{
    [self removeNotification];
}
#pragma mark - UI方法
#pragma mark 拍照
- (IBAction)takeButtonClick:(UIButton *)sender {
    //根据设备输出获得连接
    AVCaptureConnection *captureConnection=[self.captureStillImageOutput     connectionWithMediaType:AVMediaTypeVideo];
    //根据连接取得设备输出的数据
    [self.captureStillImageOutput         captureStillImageAsynchronouslyFromConnection:captureConnection     completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) {
        if (imageDataSampleBuffer) {
            NSData *imageData=[AVCaptureStillImageOutput     jpegStillImageNSDataRepresentation:imageDataSampleBuffer];
            UIImage *image=[UIImage imageWithData:imageData];
            UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);
//            ALAssetsLibrary *assetsLibrary=[[ALAssetsLibrary alloc]init];
//            [assetsLibrary writeImageToSavedPhotosAlbum:[image CGImage]     orientation:(ALAssetOrientation)[image imageOrientation]     completionBlock:nil];
        }

    }];
}
#pragma mark 切换前后摄像头
- (IBAction)toggleButtonClick:(UIButton *)sender {
    AVCaptureDevice *currentDevice=[self.captureDeviceInput device];
    AVCaptureDevicePosition currentPosition=[currentDevice position];
    [self removeNotificationFromCaptureDevice:currentDevice];
    AVCaptureDevice *toChangeDevice;
    AVCaptureDevicePosition toChangePosition=AVCaptureDevicePositionFront;
    if (currentPosition==AVCaptureDevicePositionUnspecified||currentPosition==AVCaptureDevicePositionFront) {
        toChangePosition=AVCaptureDevicePositionBack;
    }
    toChangeDevice=[self getCameraDeviceWithPosition:toChangePosition];
    [self addNotificationToCaptureDevice:toChangeDevice];
    //获得要调整的设备输入对象
    AVCaptureDeviceInput *toChangeDeviceInput=[[AVCaptureDeviceInput alloc]initWithDevice:toChangeDevice error:nil];

    //改变会话的配置前一定要先开启配置，配置完成后提交配置改变
    [self.captureSession beginConfiguration];
    //移除原有输入对象
    [self.captureSession removeInput:self.captureDeviceInput];
    //添加新的输入对象
    if ([self.captureSession canAddInput:toChangeDeviceInput]) {
        [self.captureSession addInput:toChangeDeviceInput];
        self.captureDeviceInput=toChangeDeviceInput;
    }
    //提交会话配置
    [self.captureSession commitConfiguration];

    [self setFlashModeButtonStatus];
}

#pragma mark 自动闪光灯开启
- (IBAction)flashAutoClick:(UIButton *)sender {
    [self setFlashMode:AVCaptureFlashModeAuto];
    [self setFlashModeButtonStatus];
}
#pragma mark 打开闪光灯
- (IBAction)flashOnClick:(UIButton *)sender {
    [self setFlashMode:AVCaptureFlashModeOn];
[self setFlashModeButtonStatus];
}
#pragma mark 关闭闪光灯
- (IBAction)flashOffClick:(UIButton *)sender {
    [self setFlashMode:AVCaptureFlashModeOff];
    [self setFlashModeButtonStatus];
}

#pragma mark - 通知
/**
 *  给输入设备添加通知
 */
-(void)addNotificationToCaptureDevice:(AVCaptureDevice *)captureDevice{
    //注意添加区域改变捕获通知必须首先设置设备允许捕获
    [self changeDeviceProperty:^(AVCaptureDevice *captureDevice) {
        captureDevice.subjectAreaChangeMonitoringEnabled=YES;
    }];
    NSNotificationCenter *notificationCenter= [NSNotificationCenter     defaultCenter];
    //捕获区域发生改变
    [notificationCenter addObserver:self selector:@selector(areaChange:)     name:AVCaptureDeviceSubjectAreaDidChangeNotification object:captureDevice];
}
-(void)removeNotificationFromCaptureDevice:(AVCaptureDevice *)captureDevice{
    NSNotificationCenter *notificationCenter= [NSNotificationCenter defaultCenter];
    [notificationCenter removeObserver:self name:AVCaptureDeviceSubjectAreaDidChangeNotification object:captureDevice];
}
/**
 *  移除所有通知
 */
-(void)removeNotification{
    NSNotificationCenter *notificationCenter= [NSNotificationCenter     defaultCenter];
    [notificationCenter removeObserver:self];
}

-(void)addNotificationToCaptureSession:(AVCaptureSession *)captureSession{
    NSNotificationCenter *notificationCenter= [NSNotificationCenter defaultCenter];
    //会话出错
    [notificationCenter addObserver:self     selector:@selector(sessionRuntimeError:)     name:AVCaptureSessionRuntimeErrorNotification object:captureSession];
}

/**
 *  设备连接成功
 *
 *  @param notification 通知对象
 */
-(void)deviceConnected:(NSNotification *)notification{
    NSLog(@&quot;设备已连接...&quot;);
}
/**
 *  设备连接断开
 *
 *  @param notification 通知对象
 */
-(void)deviceDisconnected:(NSNotification *)notification{
NSLog(@&quot;设备已断开.&quot;);
}
/**
 *  捕获区域改变
 *
 *  @param notification 通知对象
 */
-(void)areaChange:(NSNotification *)notification{
    NSLog(@&quot;捕获区域改变...&quot;);
}

/**
 *  会话出错
 *
 *  @param notification 通知对象
 */
-(void)sessionRuntimeError:(NSNotification *)notification{
    NSLog(@&quot;会话发生错误.&quot;);
}

#pragma mark - 私有方法

/**
 *  取得指定位置的摄像头
 *
 *  @param position 摄像头位置
 *
 *  @return 摄像头设备
 */
-(AVCaptureDevice *)getCameraDeviceWithPosition:    (AVCaptureDevicePosition )position{
NSArray *cameras= [AVCaptureDevice     devicesWithMediaType:AVMediaTypeVideo];
    for (AVCaptureDevice *camera in cameras) {
        if ([camera position]==position) {
            return camera;
        }
    }
    return nil;
}

/**
 *  改变设备属性的统一操作方法
 *
 *  @param propertyChange 属性改变操作
 */
-(void)changeDeviceProperty:(PropertyChangeBlock)propertyChange{
    AVCaptureDevice *captureDevice= [self.captureDeviceInput device];
    NSError *error;
    //注意改变设备属性前一定要首先调用lockForConfiguration:调用完之后使用    unlockForConfiguration方法解锁
    if ([captureDevice lockForConfiguration:&amp;error]) {
        propertyChange(captureDevice);
        [captureDevice unlockForConfiguration];
    }else{
        NSLog(@&quot;设置设备属性过程发生错误，错误信息：    %@&quot;,error.localizedDescription);
    }
}

/**
 *  设置闪光灯模式
 *
 *  @param flashMode 闪光灯模式
 */
-(void)setFlashMode:(AVCaptureFlashMode )flashMode{
    [self changeDeviceProperty:^(AVCaptureDevice *captureDevice) {
    if ([captureDevice isFlashModeSupported:flashMode]) {
        [captureDevice setFlashMode:flashMode];
    }
}];
}
/**
 *  设置聚焦模式
 *
 *  @param focusMode 聚焦模式
 */
-(void)setFocusMode:(AVCaptureFocusMode )focusMode{
[self changeDeviceProperty:^(AVCaptureDevice *captureDevice) {
    if ([captureDevice isFocusModeSupported:focusMode]) {
        [captureDevice setFocusMode:focusMode];
    }
}];
}
/**
 *  设置曝光模式
 *
 *  @param exposureMode 曝光模式
 */
-(void)setExposureMode:(AVCaptureExposureMode)exposureMode{
[self changeDeviceProperty:^(AVCaptureDevice *captureDevice) {
    if ([captureDevice isExposureModeSupported:exposureMode]) {
        [captureDevice setExposureMode:exposureMode];
    }
}];
}
/**
 *  设置聚焦点
 *
 *  @param point 聚焦点
 */
-(void)focusWithMode:(AVCaptureFocusMode)focusMode exposureMode:(AVCaptureExposureMode)exposureMode atPoint:(CGPoint)point{
[self changeDeviceProperty:^(AVCaptureDevice *captureDevice) {
    if ([captureDevice isFocusModeSupported:focusMode]) {
        [captureDevice setFocusMode:AVCaptureFocusModeAutoFocus];
    }
    if ([captureDevice isFocusPointOfInterestSupported]) {
        [captureDevice setFocusPointOfInterest:point];
    }
    if ([captureDevice isExposureModeSupported:exposureMode]) {
        [captureDevice setExposureMode:AVCaptureExposureModeAutoExpose];
    }
    if ([captureDevice isExposurePointOfInterestSupported]) {
        [captureDevice setExposurePointOfInterest:point];
    }
}];
}

/**
 *  添加点按手势，点按时聚焦
 */
-(void)addGenstureRecognizer{
UITapGestureRecognizer *tapGesture=[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapScreen:)];
[self.viewContainer addGestureRecognizer:tapGesture];
}
-(void)tapScreen:(UITapGestureRecognizer *)tapGesture{
CGPoint point= [tapGesture locationInView:self.viewContainer];
//将UI坐标转化为摄像头坐标
CGPoint cameraPoint= [self.captureVideoPreviewLayer captureDevicePointOfInterestForPoint:point];
[self setFocusCursorWithPoint:point];
[self focusWithMode:AVCaptureFocusModeAutoFocus exposureMode:AVCaptureExposureModeAutoExpose atPoint:cameraPoint];
}

/**
 *  设置闪光灯按钮状态
 */
-(void)setFlashModeButtonStatus{
AVCaptureDevice *captureDevice=[self.captureDeviceInput device];
AVCaptureFlashMode flashMode=captureDevice.flashMode;
if([captureDevice isFlashAvailable]){
    self.flashAutoButton.hidden=NO;
    self.flashOnButton.hidden=NO;
    self.flashOffButton.hidden=NO;
    self.flashAutoButton.enabled=YES;
    self.flashOnButton.enabled=YES;
    self.flashOffButton.enabled=YES;
    switch (flashMode) {
        case AVCaptureFlashModeAuto:
            self.flashAutoButton.enabled=NO;
            break;
        case AVCaptureFlashModeOn:
            self.flashOnButton.enabled=NO;
            break;
        case AVCaptureFlashModeOff:
            self.flashOffButton.enabled=NO;
            break;
        default:
            break;
    }
}else{
    self.flashAutoButton.hidden=YES;
    self.flashOnButton.hidden=YES;
    self.flashOffButton.hidden=YES;
}
}

/**
 *  设置聚焦光标位置
 *
 *  @param point 光标位置
 */
-(void)setFocusCursorWithPoint:(CGPoint)point{
self.focusCursor.center=point;
self.focusCursor.transform=CGAffineTransformMakeScale(1.5, 1.5);
self.focusCursor.alpha=1.0;
[UIView animateWithDuration:1.0 animations:^{
    self.focusCursor.transform=CGAffineTransformIdentity;
} completion:^(BOOL finished) {
    self.focusCursor.alpha=0;

}];
}
</code></pre>
            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2016/01/22/swift单例/" style="float: left;">
        ← swift单例
    </a>
    
    
    <a class="pull-right" href="/2016/01/18/怎么把segmentControl边框隐藏/">
        把segmentControl边框隐藏</br> →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By YueChao An. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/anyuechao" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
